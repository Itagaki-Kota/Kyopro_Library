ダイクストラ法    (コスト(辺の重み)は非負整数, 負の辺があるならベルマン・フォード法)
・幅優先探索的(BFS_like)(FIFO, キュー)   グラフにおける最小コスト(コストが最小になるようにスタートからゴールへ)
・本当のダイクストラ法は, キューから取り出される頂点は, 暫定コストが最小の頂点にする(ヒープを用いると高速に実現)


※計算量 ナイーブ　   →  N**2 ?  ヒープを使わないダイクストラ法(鉄則本p364, p365)の方が, 密グラフ(E が V**2 くらい?)では速いようだ...？
         ヒープ高速化 → (N + M)logM


典型アルゴリズム問題集 D- 単一始点最短経路問題【有向グラフ(重みあり)での, 最小コスト算出(最短経路長)】
https://atcoder.jp/contests/typical-algorithm/submissions/34854022(オレオレ実装)
https://atcoder.jp/contests/typical-algorithm/submissions/36596955(PAST本実装) PAST本 p295-298


第9回PAST I 直通エレベーター 【無向グラフ(重みあり)での, 最小コスト算出(最短経路長)】
https://atcoder.jp/contests/past202112-open/submissions/39310263
・前処理（着目する頂点のみや, 多重辺の更新など面倒）
・BFS_likeだとTLEするダイクストラ


鉄則本A64 【重み付き無向グラフにおける単一始点最短経路長】
(ヒープ実装)
https://atcoder.jp/contests/tessoku-book/submissions/37309839

鉄則本B64【経路復元】
https://atcoder.jp/contests/tessoku-book/submissions/39892454


JOIG2021本選 E- パレード(https://atcoder.jp/contests/joig2021-open/submissions/44611250)
【重みあり有向グラフにおけるダイクストラ法】
・BFS-likeだとTLEする
・今回はBFSのように、一度ある頂点を訪問すると,その頂点への最短コストが確定して, その頂点を二度探索しなくてよくなる「訳ではない」。
・辺に重みがあるので,より良い条件(←一般の最短経路問題でいうコストが小さくなること)でありうるとき, 再度その頂点をキューに入れ直す必要があり,探索回数が多くなりがち。
・さらにこの問題では「より良い条件」が単にコストが小さいというだけでなく, 逆行する辺の本数も考慮する必要があり, そのどちらの要素も捨てがたいのが難しい。
・その頂点へのこれまでの訪問履歴の中に, 「逆行する辺の本数」と「コストの総和」の両方が,上位互換である履歴が存在しなければ、その頂点は再探索すべき期待が出てきてしまう。
・ヒープを用いて(ダイクストラ的に), 常に, それまでのコストの総和が最も小さくなるような探索先の頂点をポップするようにしたら高速化された！ 
↑コストが大きくなる方を先に探索してしまうと, 後で何度も何度も更新する必要が出てくるしね...  